# Yi.Abp.Tool 架构重构与独立性分析报告

## 1. 核心问题解答

针对您提出的关于 `Yi.Abp.Tool` 模块独立性、模板维护及仓库管理的疑问，以下是直接的分析解答：

### Q1: 可以在 `.csproj` 中设置让使用者 clone 时不复制 tool 模块吗？
**答案：不可以。**
*   `.csproj` 是 .NET 项目的构建配置文件，它控制的是编译 (`Build`)、打包 (`Pack`) 和发布 (`Publish`) 的行为，**它无法控制 Git 的行为**。
*   当用户执行 `git clone` 时，Git 会下载仓库中的**所有**文件。您无法通过修改代码文件来阻止 Git 下载某些文件夹。

### Q2: 是否需要维护一个不包含 tool 的“可用模板”？
**答案：是的，必须这样。**
*   **现状**：目前 `CloneCommand` (在 `CloneCommand.cs` 中) 是直接克隆整个框架仓库 (`https://gitee.com/ccnetcore/Yi`)。这意味着用户确实会把源码里的 `tool`、`tests`、`docs` 等全部下载下来。
*   **改进**：用户需要的“模板”应该是一个纯净的、最小化的启动项目。您应该在 Gitee 上维护一个单独的分支（例如 `template` 分支）或者一个完全独立的仓库（例如 `Yi.Template`），里面**只包含**用户需要的代码（Web + 必要的 Module），**不包含** Tool 的源码。

### Q3: 将 tool 模块完全独立出来（单独仓库）可以吗？
**答案：完全可以。**
*   Tool 本质上是一个独立的控制台程序，它只依赖编译好的 DLL 或 API 契约，不依赖框架源码。将其放入单独的仓库（如 `Yi.Abp.Tool` 仓库）是标准做法。

### Q4: Tool 项目和模板项目一般不会频繁变化对吧？
**答案：这取决于框架的成熟度（这是一个常见的误区）。**
*   **模板 (Template)**：实际上**变化频率较高**。每当框架 (`sharpfort.net`) 更新了启动配置、改变了依赖注入方式、或者升级了 NuGet 包版本，模板都必须同步更新，否则用户下载的模板无法运行最新的框架。
*   **工具 (Tool)**：逻辑变化频率较低，但如果模板的目录结构发生变化，Tool 中负责生成代码的逻辑（脚手架）也需要修改。

---

## 2. 架构方案对比：Monorepo vs Polyrepo

鉴于您计划分别维护 `sharpfort.net` (核心框架)、`tool` (工具) 和 `template` (模板)，这里提供两种主流方案的利弊分析。

### 方案 A：完全分离策略 (Polyrepo) —— 适合成熟期
将项目拆分为三个独立的 Git 仓库：
1.  **Framework Repo**: 只包含核心库代码。
2.  **Tool Repo**: 只包含 CLI 工具代码。
3.  **Template Repo**: 只包含给用户的启动项目代码。

| 维度 | 优势 | 劣势 |
| :--- | :--- | :--- |
| **清晰度** | 极高。用户 clone 模板时，只能看到业务代码，没有框架源码或工具源码干扰。 | **维护成本高**。发布一个新特性可能需要三个仓库配合：先发 Framework NuGet -> 再升级 Template 依赖 -> 最后更新 Tool 逻辑。 |
| **独立性** | 各自独立版本号，职责分明。 | **同步困难**。容易出现 Tool 生成的代码不适配最新 Framework 的情况。 |
| **用户体验** | 最好。下载即用，体积小。 | 开发者调试框架源码不便（需要手动 link）。 |

### 方案 B：主从分离策略 (推荐) —— 适合快速迭代期
保留 **Monorepo (单体仓库)** 用于开发和维护，利用 **CI/CD (自动化脚本)** 进行分离发布。

*   **仓库结构**：
    *   `/framework` (核心代码)
    *   `/tool` (工具代码)
    *   `/templates` (维护在本地的模板源文件)
*   **发布流程**：
    1.  **Tool**: 编译打包为 NuGet Tool 包发布。用户通过 `dotnet tool install` 安装，而不是 clone 源码。
    2.  **Template**: 写一个脚本，自动将 `/templates` 目录下的内容推送到一个**只读的** Git 分支或单独的 Git 仓库。

| 维度 | 优势 | 劣势 |
| :--- | :--- | :--- |
| **开发效率** | 高。修改框架核心时，可以立即测试对模板和工具的影响（原子提交）。 | 设置自动化发布流程稍微复杂。 |
| **一致性** | 强。保证工具、模板、框架始终是同一版本。 | 仓库体积较大。 |

---

## 3. 针对您的建议实施路径

根据您的需求，建议采用 **“源码不分家，发布产物分家”** 的混合模式。这是维护成本最低且对用户最友好的方式。

### 步骤 1：改造 Tool 的分发方式
*   **不要让用户 Clone Tool 的源码**。
*   在 `Yi.Abp.Tool.csproj` 中保留 `<PackAsTool>true</PackAsTool>`。
*   将编译好的包发布到 NuGet (或私有源)。
*   **用户操作**：`dotnet tool install -g Yi.Abp.Tool`。

### 步骤 2：建立独立的“模板源”
*   您不能让用户 Clone 整个 `Yi` 仓库作为起点。
*   **做法**：
    1.  在当前仓库中创建一个文件夹（如 `template-source`），里面放一个干净的、标准的启动项目。
    2.  利用 Git Subtree 或者 CI/CD 脚本，每次提交时，将这个文件夹的内容同步到一个**新的、独立的 Gitee 仓库** (例如 `Yi.Template`)。
    3.  或者，在 Tool 的 `NewCommand` 中，修改逻辑，不再是 `git clone <主仓库>`, 而是下载您打包好的 ZIP 文件，或者 `git clone <专门的模板仓库>`。

### 步骤 3：Tool 的代码调整
*   修改 `tool/Yi.Abp.Tool/Commands/CloneCommand.cs`:
    *   **原逻辑**: `git clone https://gitee.com/ccnetcore/Yi` (这会下载所有东西)
    *   **新逻辑**: `git clone https://gitee.com/ccnetcore/Yi.Template` (指向新的、干净的模板仓库)

## 4. 总结
1.  **Yi.Abp.Tool 应该保留在主仓库中**，方便您开发维护，但**不应该**让用户通过 Clone 源码的方式去使用它。用户应该通过 NuGet 安装编译后的工具。
2.  **必须剥离模板**。您需要建立一个专门存放“干净启动项目”的地方（单独的分支或仓库），Tool 的 `new` 或 `clone` 命令应该指向这个干净的地方，而不是主仓库。
3.  **Tool 模块可以移除**。如果采用了上述 NuGet 安装方式，主框架的解决方案中完全可以移除 `tool` 文件夹，互不影响。但为了方便您自己开发，建议留着。
